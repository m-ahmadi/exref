/*
	a subquery or Inner query or Nested query is a query within another PostgreSQL query and embedded within the WHERE clause.
	a subquery is used to return data that will be used in the main query as a condition to further restrict the data to be retrieved.
	subqueries can be used with the SELECT, INSERT, UPDATE and DELETE statements along with the operators like =, <, >, >=, <=, IN, etc.
	there are a few rules that subqueries must follow âˆ’
		subqueries must be enclosed within parentheses.
		a subquery can have only one column in the SELECT clause, unless multiple columns are in the main query for the subquery to compare its selected columns.
		an ORDER BY cannot be used in a subquery, although the main query can use an ORDER BY. The GROUP BY can be used to perform the same function as the ORDER BY in a subquery.
		subqueries that return more than one row can only be used with multiple value operators, such as the IN, EXISTS, NOT IN, ANY/SOME, ALL operator.
		the BETWEEN operator cannot be used with a subquery; however, the BETWEEN can be used within the subquery.
	subqueries can be nested as deep as you want.
*/

-- if a column values matches what is in a specified list:
SELECT lastname, firstname, state
FROM author
WHERE state IN ('IL', 'UT', 'MI')
ORDER BY 1, 2, 3;

-- The values in the list can be generated by another SELECT statement instead of keyed in directly to the statement:
SELECT lastname, firstname, state
FROM author
WHERE state IN (SELECT DISTINCT state FROM publisher)
ORDER BY 1, 2, 3;
--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-- generated values by a sql statement must match the kind of value being compared to the left of the IN operator.
-- this would be a mistake:
SELECT lastname, firstname, state
FROM author
WHERE city IN
	(SELECT DISTINCT state FROM publisher)
ORDER BY 1, 2, 3;
-- why: comparing the city column to a generated list of states
--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
--  you must compare one column to a list of values generated from one column.
-- this would be a mistake:
SELECT lastname, firstname, state
FROM author
WHERE city IN
	(SELECT city, state FROM publisher)
ORDER BY 1, 2, 3;
-- why: you can't compare a city to a city and a state (you can't do SELECT * as well)
--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-- another example:
SELECT lastname, firstname, 'wrote more than one book'
FROM author
WHERE author_id IN
	(SELECT DISTINCT author_id
	 FROM bookauthor
	 GROUP BY author_id
	 HAVING count(*) > 1)
ORDER BY 1, 2;
--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-- with a subquery you can get results from a table using information from that same table
-- see all the books that have the same price as books that begin with 'How'
SELECT title, price
FROM book
WHERE price IN
	(SELECT DISTINCT price
	 FROM book
	 WHERE title LIKE 'How%')
ORDER BY 1, 2;
--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-- which authors sell books that cost 12.99:
SELECT lastname, firstname, 'sell books at 12.99'
FROM author
WHERE author_id IN
  (SELECT author_id FROM bookauthor WHERE isbn IN
     (SELECT isbn FROM book WHERE price = 12.99))
ORDER BY 1, 2;
--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
/*	Subqueries with a Comparison Operator
	when you use a comparison operator, instead of an IN, the inner query MUST return exactly one single value. (i.e. one row, one cell),
	otherwise it's an error condition
	how can you be absolutely sure you get one value returned from a SELECT statement?
	using an aggregate function like AVG or SUM
*/
-- find books which have greater price than the average price of books:
SELECT title, price
FROM book
WHERE price >
  (SELECT AVG(price) FROM book)
ORDER BY 1;

-- another example:
SELECT title, ytd_sales, price
FROM book
WHERE ytd_sales >
	(SELECT SUM(ytd_sales) - 30000 FROM book WHERE price < 20)
ORDER BY 1, 2, 3;

-- you can use a subquery with the HAVING clause:
SELECT type, SUM(ytd_sales)
FROM book
GROUP BY type
HAVING AVG(ytd_sales) >
	(SELECT AVG(ytd_sales) FROM book)
ORDER BY 1, 2;